<!DOCTYPE html>
<html>
<head>
  <title>DragonLi Web Interface</title>
  <style>
    #markdown-content {
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>DragonLi</h1>
   <!-- <p> <del>A cat</del> A word equation solver</p>-->
  <p>A word equation solver</p>

  <form onsubmit="return sendForm(event)">
    <!-- select benchmark -->
    <label for="benchmark">Benchmark:</label>
    <select id="benchmark" name="benchmark">
      <option value="A1">A1</option>
      <option value="A2">A2</option>
      <option value="B">B</option>
      <option value="C">C</option>
    </select>

    <!-- button to generate a benchmark -->
    <button type="button" onclick="generateBenchmark()">Generate one example</button>
    <br /><br />

    <!-- select rank function -->
    <label for="solverType">RankEqs function:</label>
    <select id="solverType" name="solverType">
      <option value="category">Baseline</option>
      <option value="hybrid_category_gnn_random">Random</option>
      <option value="category_gnn_first_n_iterations">GNN</option>
    </select>

    <!-- select task -->
    <label for="rankTask">Rank task:</label>
    <select id="rankTask" name="rankTask">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
    </select>
    <br /><br />

    <!-- select timeout_in_second -->
    <label for="timeout_in_second">Timeout in second:</label>
    <select id="timeout_in_second" name="timeout_in_second">
      <option value="30">30</option>
      <option value="60">60</option>
      <option value="300">300</option>
    </select>
    <br /><br />

    <label for="userInput">Enter a word equation problem:</label><br /><br />
    <textarea id="userInput" name="userInput" rows="30" cols="180"></textarea>
    <br /><br />

    <!-- Existing submit button -->
    <button type="submit">Submit</button>

  </form>

  <!-- Output area for solver messages -->
  <div id="solverOutput"
     style="margin-top: 20px; border: 1px solid #ccc; padding: 10px;">
  <!-- Will be filled in by JavaScript -->
  </div>

  <!-- Output area for solver time messages -->
<div id="solverOutputTime"
     style="margin-top: 20px; border: 1px solid #ccc; padding: 10px;">
  <!-- Will be filled in by JavaScript -->
</div>




  <!-- "Span button" to toggle the markdown -->
<span id="toggle-span">[+]</span>
<span>Click to show/hide the grammar</span>

<!-- Hidden container for rendered markdown -->
<div id="markdown-content" style="display: none; margin-top: 10px;"></div>

  <script>
    // 1. On page load, fetch the file contents from /load-eq
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        const response = await fetch('/load-eq');
        if (!response.ok) {
          throw new Error('Error fetching EQ file');
        }
        const fileContents = await response.text();
        document.getElementById('userInput').value = fileContents;
      } catch (error) {
        console.error('Could not load file:', error);
      }
    });

    // 2. On submit, POST the userâ€™s text to /process, run solver, and get answer
    async function sendForm(event) {

      event.preventDefault();
      const solverOutputDiv = document.getElementById('solverOutput');
      solverOutputDiv.textContent = 'Processing...';

      const solverOutputTimeDiv = document.getElementById('solverOutputTime');
      solverOutputTimeDiv.textContent = '...';

      // Extract values from the form
      const input = document.getElementById('userInput').value;
      const solverType = document.getElementById('solverType').value;
      const rankTask = document.getElementById('rankTask').value;
      const benchmark = document.getElementById('benchmark').value;
      const timeout_in_second = document.getElementById('timeout_in_second').value;

      try {
        const response = await fetch('/process', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userInput: input,
            solverType: solverType,
            rankTask: rankTask,
            benchmark: benchmark,
            timeout_in_second: timeout_in_second
          })
        });

        const result = await response.json();
        if (response.ok) {
          solverOutputDiv.textContent = result.solverOutput;
          solverOutputTimeDiv.textContent = result.solverOutputTime;
        } else {
          solverOutputDiv.textContent =
            'Solver Error: ' + (result.message || 'Unknown error');
        }
      } catch (error) {
        console.error('Network or server error:', error);
        solverOutputDiv.textContent =
          'An error occurred. Check the console for details.';
      }
      return false;
    }

    // 3. Generate Benchmark function
      async function generateBenchmark() {

    const solverOutputDiv = document.getElementById('solverOutput');

    solverOutputDiv.textContent = 'Generating benchmark...';

    const benchmark = document.getElementById('benchmark').value;

    try {
      const response = await fetch('/generate-benchmark', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ benchmark })
      });

      if (!response.ok) {
        const errorResult = await response.json();
        solverOutputDiv.textContent = 'Generator Error: ' + (errorResult.message || 'Unknown error');
        return;
      }

      // If successful, fetch updated user-input.eq
      const fileResponse = await fetch('/load-eq');
      if (!fileResponse.ok) {
        throw new Error('Error fetching updated EQ file');
      }
      const fileContents = await fileResponse.text();
      document.getElementById('userInput').value = fileContents;
      solverOutputDiv.textContent = 'Benchmark generated successfully.';
    } catch (error) {
      console.error('Error generating benchmark:', error);
      solverOutputDiv.textContent = 'Error generating benchmark.';
    }
  }
  </script>


<!-- Load the Marked library (CDN link) -->
<script src="https://cdn.jsdelivr.net/npm/marked@4.2.12/marked.min.js"></script>

<script>
// 1. Our Markdown text:
const markdownText = `
\`\`\`markdown
<formula>  ::= <equation> ( "\n" <equation> )*
<equation> ::= <word> "=" <word>
<word>     ::= <symbol>*
<symbol>   ::= <variable> | <terminal>
<variables> and <terminals> can be any string identifier without space, for instance "X", "Y", "var_0", "const_1", etc.
Identifiers should be unique strings.
\`\`\`
`;

// 2. Convert to HTML:
const renderedHtml = marked.parse(markdownText);

// 3. Inject into the page (but keep hidden by default)
document.getElementById('markdown-content').innerHTML = renderedHtml;

// 4. Simple toggle function
document.getElementById('toggle-span').addEventListener('click', () => {
  const content = document.getElementById('markdown-content');
  const toggle = document.getElementById('toggle-span');

  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '[-]';
  } else {
    content.style.display = 'none';
    toggle.textContent = '[+]';
  }
});
</script>
</body>
</html>
